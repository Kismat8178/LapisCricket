<!DOCTYPE html>
<html>
<head>
<title>2D Cricket Game</title>
<style>
  body {
    margin: 0;
    padding: 0;
    overflow: hidden; /* Hide scrollbars */
    background-color: #1a1a1a;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: sans-serif;
    color: #fff;
  }

  canvas {
    border: 1px solid #555;
    background-color: #336633; /* Green ground */
    display: block; /* Remove extra space below canvas */
  }

  #gameContainer {
      position: relative;
      text-align: center; /* Center start button etc. */
  }

  #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent overlay */
      z-index: 10; /* Above canvas */
      color: white;
      font-size: 20px;
      text-align: center;
  }

  #overlay button {
      padding: 10px 20px;
      margin: 10px;
      font-size: 18px;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
  }

   #overlay button:hover {
       background-color: #45a049;
   }

   #overlay div {
       margin-bottom: 20px;
   }

</style>
</head>
<body>

<div id="gameContainer">
    <canvas id="cricketCanvas" width="800" height="600"></canvas>
    <div id="overlay">
        <h2>2D Cricket</h2>
        <p>Loading...</p>
    </div>
</div>

<script>
  const canvas = document.getElementById('cricketCanvas');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');

  // Game Constants
  const GAME_WIDTH = canvas.width;
  const GAME_HEIGHT = canvas.height;
  const PITCH_Y = GAME_HEIGHT / 2;
  const PITCH_WIDTH = GAME_WIDTH * 0.8;
  const PITCH_START_X = (GAME_WIDTH - PITCH_WIDTH) / 2;
  const PITCH_END_X = PITCH_START_X + PITCH_WIDTH;
  const WICKET_WIDTH = 5;
  const WICKET_HEIGHT = 30;
  const BALL_RADIUS = 8;
  const BATSMAN_WIDTH = 20;
  const BATSMAN_HEIGHT = 40;
  const BOWLER_WIDTH = 20;
  const BOWLER_HEIGHT = 40;
  const BAT_LENGTH = 40; // Length from pivot
  const BAT_SWING_ARC = Math.PI / 1.5; // Angle of swing
  const BAT_SWING_SPEED = 0.2; // How fast the bat swings per frame
  const MAX_BALL_SPEED = 10;
  const MIN_BALL_SPEED = 5;
  const MAX_SWING_POWER_MULTIPLIER = 1.5; // Max speed multiplier when hitting
  const OVERS_PER_INNINGS = 5;
  const WICKETS_PER_INNINGS = 5; // Game ends if this many wickets fall

  // Game State
  let game = {
    state: 'Loading', // Loading, Menu, Toss, Playing, InningsBreak, GameOver
    score: { player: 0, ai: 0 },
    wickets: { player: 0, ai: 0 },
    overs: { current: 0, deliveries: 0 },
    totalOvers: OVERS_PER_INNINGS,
    maxWickets: WICKETS_PER_INNINGS,
    battingTeam: null, // 'player' or 'ai'
    bowlingTeam: null, // 'player' or 'ai'
    tossResult: null, // 'player' or 'ai'
    tossChoice: null, // 'bat' or 'bowl' - winner's choice
    aiTossChoice: null, // 'heads' or 'tails'
    playerTossChoice: null, // 'heads' or 'tails'
    message: '',
    ball: { x: 0, y: 0, dx: 0, dy: 0, radius: BALL_RADIUS, state: 'idle' }, // idle, bowling, batted
    batsman: { x: PITCH_START_X + 50, y: PITCH_Y - BATSMAN_HEIGHT / 2, width: BATSMAN_WIDTH, height: BATSMAN_HEIGHT, batAngle: 0, swinging: false, swingProgress: 0 },
    bowler: { x: PITCH_END_X - 50, y: PITCH_Y - BOWLER_HEIGHT / 2, width: BOWLER_WIDTH, height: BOWLER_HEIGHT },
    joystick: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, centerX: 0, centerY: 0, radius: 50, angle: 0, power: 0 },
    animationId: null,
    innings: 1,
    target: null,
    lastBallAction: null, // 'score', 'wicket', 'dot', 'wide', 'no-ball' (simplified: score/wicket/dot)
    canBowl: true, // Flag to prevent multiple bowls
    canBat: true, // Flag to prevent multiple swings per delivery
    inputActive: false // Flag to know if player input (joystick/bowl click) is relevant
  };

  // --- Drawing Functions ---
  function drawPitch() {
    ctx.fillStyle = '#c49a64'; // Brown pitch color
    ctx.fillRect(PITCH_START_X, PITCH_Y - 20, PITCH_WIDTH, 40); // Pitch area
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(PITCH_START_X, PITCH_Y);
    ctx.lineTo(PITCH_END_X, PITCH_Y);
    ctx.stroke(); // Center line

    // Wickets
    ctx.fillStyle = '#eee';
    ctx.fillRect(PITCH_START_X, PITCH_Y - WICKET_HEIGHT / 2, WICKET_WIDTH, WICKET_HEIGHT); // Batsman end wicket
    ctx.fillRect(PITCH_END_X - WICKET_WIDTH, PITCH_Y - WICKET_HEIGHT / 2, WICKET_WIDTH, WICKET_HEIGHT); // Bowler end wicket
  }

  function drawBatsman() {
    const b = game.batsman;
    ctx.fillStyle = game.battingTeam === 'player' ? '#00f' : '#f00'; // Player blue, AI red
    ctx.fillRect(b.x, b.y, b.width, b.height);

    // Draw bat (simplified)
    ctx.save();
    ctx.translate(b.x + b.width / 2, b.y + b.height * 0.75); // Pivot point near hands/waist
    ctx.rotate(b.batAngle);
    // Bat is drawn downwards from pivot
    ctx.fillStyle = '#8B4513'; // Brown color
    ctx.fillRect(-5, -BAT_LENGTH, 10, BAT_LENGTH);
    ctx.restore();
  }

  function drawBowler() {
    const b = game.bowler;
    ctx.fillStyle = game.bowlingTeam === 'player' ? '#00f' : '#f00'; // Player blue, AI red
    ctx.fillRect(b.x, b.y, b.width, b.height);
  }

  function drawBall() {
    const ball = game.ball;
    if (ball.state === 'idle') return;
    ctx.fillStyle = '#eee'; // White ball
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawScoreboard() {
    ctx.fillStyle = '#fff';
    ctx.font = '20px Arial';
    ctx.textAlign = 'left';
    const playerScore = `${game.score.player}/${game.wickets.player}`;
    const aiScore = `${game.score.ai}/${game.wickets.ai}`;
    const overs = `${game.overs.current}.${game.overs.deliveries}`;

    let scoreText = `YOU: ${playerScore}`;
    let opponentText = `AI: ${aiScore}`;
    let oversText = `Overs: ${overs}`;
    let targetText = game.innings === 2 ? `Target: ${game.target + 1}` : ''; // Need 1 more than target score

    // Determine which score to show on left/right based on who is batting
    if (game.battingTeam === 'player') {
       ctx.fillText(scoreText, 20, 30);
       ctx.fillText(opponentText, GAME_WIDTH - ctx.measureText(opponentText).width - 20, 30);
    } else {
        ctx.fillText(opponentText, 20, 30);
        ctx.fillText(scoreText, GAME_WIDTH - ctx.measureText(scoreText).width - 20, 30);
    }


    ctx.textAlign = 'center';
    ctx.fillText(oversText, GAME_WIDTH / 2, 30);

    if (targetText) {
        ctx.fillText(targetText, GAME_WIDTH / 2, 60);
    }
  }

  function drawMessage() {
      if (!game.message) return;
      ctx.fillStyle = '#fff';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(game.message, GAME_WIDTH / 2, 100);
  }

  function drawJoystick() {
      if (game.state !== 'Playing' || game.battingTeam !== 'player') return;

      const j = game.joystick;
      const size = j.radius * 2.5; // Make joystick area larger for easier touch

      // Determine position - maybe bottom left?
      j.centerX = GAME_WIDTH * 0.15;
      j.centerY = GAME_HEIGHT * 0.85;


      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(j.centerX, j.centerY, j.radius, 0, Math.PI * 2);
      ctx.stroke(); // Base circle

      // Draw thumb
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(j.currentX, j.currentY, j.radius * 0.6, 0, Math.PI * 2);
      ctx.fill();

      // Draw power indicator line
      if (j.active) {
           ctx.strokeStyle = '#0f0'; // Green
           ctx.lineWidth = 3;
           ctx.beginPath();
           ctx.moveTo(j.centerX, j.centerY);
           ctx.lineTo(j.currentX, j.currentY);
           ctx.stroke();
      }
  }


  // --- Game Logic Functions ---

  function initGame() {
      game.state = 'Menu';
      game.score = { player: 0, ai: 0 };
      game.wickets = { player: 0, ai: 0 };
      game.overs = { current: 0, deliveries: 0 };
      game.innings = 1;
      game.target = null;
      game.canBowl = true;
      game.canBat = true;
      game.ball.state = 'idle';
      game.message = 'Click START to Play';
      updateOverlay();
  }

  function startGame() {
      game.state = 'Toss';
      game.message = 'Choose Heads or Tails';
      updateOverlay();
  }

  function handleToss(choice) {
      game.playerTossChoice = choice;
      const coin = Math.random() < 0.5 ? 'heads' : 'tails';
      game.tossResult = (game.playerTossChoice === coin) ? 'player' : 'ai';

      if (game.tossResult === 'player') {
          game.message = `You won the toss! Choose to Bat or Bowl.`;
          updateOverlay('chooseBatBowl');
      } else {
          game.aiTossChoice = Math.random() < 0.5 ? 'bat' : 'bowl'; // AI randomly chooses
          game.tossChoice = game.aiTossChoice;
          game.message = `AI won the toss and chose to ${game.aiTossChoice}.`;
          setInningsRoles();
          updateOverlay('tossResult'); // Show result, then start game
      }
  }

  function handleTossChoice(choice) {
      game.tossChoice = choice;
      game.message = `You chose to ${choice}.`;
      setInningsRoles();
      updateOverlay('tossResult'); // Show result, then start game
  }

  function setInningsRoles() {
      if (game.tossResult === 'player') {
          game.battingTeam = game.tossChoice;
          game.bowlingTeam = game.tossChoice === 'bat' ? 'ai' : 'player';
      } else { // AI won toss
          game.battingTeam = game.aiTossChoice;
          game.bowlingTeam = game.aiTossChoice === 'bat' ? 'ai' : 'player';
      }
      // Swap batsman/bowler positions based on who is batting
      if (game.battingTeam === 'ai') {
          game.batsman.x = PITCH_END_X - 50 - BATSMAN_WIDTH;
          game.bowler.x = PITCH_START_X + 50;
      } else {
          game.batsman.x = PITCH_START_X + 50;
          game.bowler.x = PITCH_END_X - 50 - BOWLER_WIDTH;
      }
  }


  function startInnings() {
    // Reset relevant state for new innings
    game.score[game.battingTeam] = 0;
    game.wickets[game.battingTeam] = 0;
    game.overs = { current: 0, deliveries: 0 };
    game.ball.state = 'idle';
    game.canBowl = true;
    game.canBat = true;
    game.lastBallAction = null;
    game.message = game.battingTeam === 'player' ? 'Your turn to bat!' : 'AI is batting!';
    game.state = 'Playing';
    updateOverlay(); // Hide overlay
    // Ensure batsman/bowler are in correct starting positions
     if (game.battingTeam === 'ai') {
          game.batsman.x = PITCH_END_X - 50 - BATSMAN_WIDTH;
          game.bowler.x = PITCH_START_X + 50;
      } else {
          game.batsman.x = PITCH_START_X + 50;
          game.bowler.x = PITCH_END_X - 50 - BOWLER_WIDTH;
      }
  }


  function nextDelivery() {
      game.overs.deliveries++;
      game.ball.state = 'idle';
      game.ball.dx = 0;
      game.ball.dy = 0;
      game.canBowl = true; // Allow next bowl
      game.canBat = true; // Allow swing for next ball
      game.joystick.active = false; // Reset joystick state
      game.joystick.currentX = game.joystick.centerX;
      game.joystick.currentY = game.joystick.centerY;


      if (game.overs.deliveries >= 6) {
          endOver();
      } else {
         // Message depends on who's bowling next ball
         game.message = game.bowlingTeam === 'player' ? 'Click pitch to Bowl' : 'AI Bowling...';
      }

       // Check for innings end after updating overs/deliveries
       if (game.wickets[game.battingTeam] >= game.maxWickets || (game.overs.current >= game.totalOvers && game.overs.deliveries === 0)) {
           endInnings();
       } else {
            // In second innings, check if target is met
           if (game.innings === 2 && game.score.player > game.target) {
               endGame('player');
           } else if (game.innings === 2 && game.score.ai > game.target) {
               endGame('ai');
           }
       }
  }

  function endOver() {
      game.overs.current++;
      game.overs.deliveries = 0;

      if (game.wickets[game.battingTeam] < game.maxWickets && game.overs.current < game.totalOvers) {
           game.message = `Over ${game.overs.current} completed.`;
           // In a real game, ends switch. For simplicity, we just reset delivery count.
      }
      // Check for innings/game end handled in nextDelivery or EndInnings/EndGame calls
  }

  function endInnings() {
      game.message = `${game.battingTeam.toUpperCase()} Innings Ended. Score: ${game.score[game.battingTeam]}/${game.wickets[game.battingTeam]}.`;

      if (game.innings === 1) {
          game.target = game.score[game.battingTeam];
          game.innings = 2;
          // Swap roles for the second innings
          const tempTeam = game.battingTeam;
          game.battingTeam = game.bowlingTeam;
          game.bowlingTeam = tempTeam;
          game.state = 'InningsBreak';
          updateOverlay('inningsBreak'); // Show innings break message
      } else {
          // End of second innings
          const playerFinalScore = game.score.player;
          const aiFinalScore = game.score.ai;

          if (playerFinalScore > aiFinalScore) {
              endGame('player');
          } else if (aiFinalScore > playerFinalScore) {
               endGame('ai');
          } else {
               endGame('tie'); // Should be rare with 4s/6s
          }
      }
  }

  function endGame(winner) {
      game.state = 'GameOver';
      if (winner === 'player') {
          game.message = `Game Over! YOU WIN! Your Score: ${game.score.player}/${game.wickets.player}. AI Score: ${game.score.ai}/${game.wickets.ai}.`;
      } else if (winner === 'ai') {
          game.message = `Game Over! AI WINS! Your Score: ${game.score.player}/${game.wickets.player}. AI Score: ${game.score.ai}/${game.wickets.ai}.`;
      } else {
           game.message = `Game Over! It's a TIE! Your Score: ${game.score.player}/${game.wickets.player}. AI Score: ${game.score.ai}/${game.wickets.ai}.`;
      }
       updateOverlay('gameOver'); // Show game over message
       cancelAnimationFrame(game.animationId); // Stop the game loop
  }

  // --- Ball & Bat Physics (Simplified) ---

  function checkCollision() {
      const ball = game.ball;
      const bat = game.batsman;

      // Simple collision check: Is ball near the bat's swing path when swinging?
      if (game.battingTeam === 'player' && bat.swinging && game.canBat && ball.state === 'bowling') {
         // Define the bat's current position (end point) based on angle
         const pivotX = bat.x + bat.width / 2;
         const pivotY = bat.y + bat.height * 0.75;
         const batTipX = pivotX + Math.cos(bat.batAngle) * BAT_LENGTH;
         const batTipY = pivotY + Math.sin(bat.batAngle) * BAT_LENGTH;

         // Check distance from ball to bat tip or maybe the bat line segment
         // Simplified: check distance from ball to the pivot + bat length along angle
         const distToPivot = Math.sqrt(Math.pow(ball.x - pivotX, 2) + Math.pow(ball.y - pivotY, 2));
         // Angle between pivot-to-ball and pivot-to-bat
         const angleToBall = Math.atan2(ball.y - pivotY, ball.x - pivotX);
         const angleDiff = Math.abs(angleToBall - bat.batAngle);

         // Check if ball is within range and within a reasonable angle tolerance of the bat face
         if (distToPivot < BAT_LENGTH + ball.radius && angleDiff < Math.PI / 6) { // Tolerance 30 degrees
             handleBallHit();
             game.canBat = false; // Bat can only hit once per delivery
         }
      }
  }

  function handleBallHit() {
      const ball = game.ball;
      const bat = game.batsman;
      game.ball.state = 'batted';
      game.message = 'HIT!';

      // Calculate new direction based on bat angle and power
      const hitAngle = bat.batAngle + (Math.random() - 0.5) * Math.PI / 8; // Add slight randomness
      const hitPower = game.joystick.power / game.joystick.radius; // 0 to 1 based on drag distance

      // Base speed + bonus from power
      const speed = MIN_BALL_SPEED + (MAX_BALL_SPEED - MIN_BALL_SPEED) * 0.5 + hitPower * (MAX_BALL_SPEED - MIN_BALL_SPEED) * MAX_SWING_POWER_MULTIPLIER;

      ball.dx = Math.cos(hitAngle) * speed;
      ball.dy = Math.sin(hitAngle) * speed * 0.5; // Reduce vertical speed for more horizontal shots
  }


  function checkScore() {
      const ball = game.ball;

      if (ball.state === 'batted') {
          // Ball hit by bat
          if (ball.y < 0 || ball.y > GAME_HEIGHT) {
              // Out of vertical bounds - count as 6
              game.message = 'SIX!';
              game.score[game.battingTeam] += 6;
              game.lastBallAction = 'score';
          } else if (ball.x < 0 || ball.x > GAME_WIDTH) {
               // Out of horizontal bounds - count as 4
              game.message = 'FOUR!';
              game.score[game.battingTeam] += 4;
              game.lastBallAction = 'score';
          } else if (ball.x < PITCH_START_X || ball.x > PITCH_END_X) {
              // Ball is off the pitch area but within field bounds (not 4 or 6)
              // Wait for the ball to slow down/stop before next delivery
              // For simplicity in V1, just consider it a dot ball once it stops
              // Or, stop it after it travels a certain distance off the pitch
              if (Math.abs(ball.dx) < 0.5 && Math.abs(ball.dy) < 0.5) { // Ball almost stopped
                  game.message = 'No run.';
                  game.lastBallAction = 'dot';
                  // Reset ball state only *after* message has been seen or timed out?
                  // Simpler: just call nextDelivery immediately after detecting it went off pitch but not boundary
                  // Or, let it travel a bit, then trigger next delivery
                  // Let's add a timeout before calling nextDelivery after a hit stays in field
                   if (!game._hitTimer) { // Prevent multiple timers
                     game._hitTimer = setTimeout(() => {
                         game.message = 'No run.';
                         game.lastBallAction = 'dot';
                         nextDelivery();
                         game._hitTimer = null;
                     }, 1000); // Wait 1 second
                   }
              }

          } else {
             // Ball is still on the pitch area after being hit - maybe hit wicket?
             // Or it will just go off the side eventually
             // We handle wicket check below
             // If it stays on pitch but doesn't hit wicket, maybe it was caught?
             // For V1, assume anything on pitch after hit is either wicket or will eventually go off.
             // Let's not trigger nextDelivery yet, let it move.
          }

      } else if (ball.state === 'bowling') {
          // Ball bowled, not hit by bat
          const batsmanWicketX = PITCH_START_X + WICKET_WIDTH / 2;
          const batsmanWicketY = PITCH_Y;

          // Check if ball reached or passed batsman's wicket position
          // Check needs to be based on the bowling direction
          const reachedBatsman = (game.bowlingTeam === 'ai' && ball.x <= batsmanWicketX) ||
                                 (game.bowlingTeam === 'player' && ball.x >= batsmanWicketX);

          if (reachedBatsman) {
              // Check for Wicket (hitting the stumps area)
              const wicketTop = PITCH_Y - WICKET_HEIGHT / 2;
              const wicketBottom = PITCH_Y + WICKET_HEIGHT / 2;
              const wicketLeft = PITCH_START_X; // Batsman end wicket X
              const wicketRight = PITCH_START_X + WICKET_WIDTH;

              // Check if ball is within the wicket's horizontal and vertical bounds
              if (ball.x >= wicketLeft && ball.x <= wicketRight &&
                  ball.y >= wicketTop && ball.y <= wicketBottom) {
                  game.message = 'WICKET!';
                  game.wickets[game.battingTeam]++;
                  game.lastBallAction = 'wicket';
                  nextDelivery(); // End of delivery
              } else {
                  // Ball passed the wicket without hitting it
                  // Check for Byes/Leg Byes? No, simpler: check for Wide/No-ball or just a miss (dot ball)
                  // For simplicity, if it wasn't hit and didn't hit the wicket, it's a dot ball.
                  // Or maybe check if it went wide?
                   const WIDE_MARGIN_Y = 20; // How far vertically off the pitch line is a wide
                   if (Math.abs(ball.y - PITCH_Y) > WIDE_MARGIN_Y &&
                       ((game.bowlingTeam === 'ai' && ball.x < batsmanWicketX) ||
                        (game.bowlingTeam === 'player' && ball.x > batsmanWicketX)) // Check after it passed wicket
                       ) {
                       // It's a wide or passed wide - count as dot for simplicity unless we add extras later
                       game.message = 'Wide? No Run.'; // Simplified: just a miss
                       game.lastBallAction = 'dot';
                       nextDelivery();
                   }
                   else if (Math.abs(ball.x - batsmanWicketX) > 10){ // Passed wicket horizontally significantly
                       game.message = 'Missed.';
                       game.lastBallAction = 'dot';
                       nextDelivery();
                   }
                   // else the ball might still be moving towards the wicket area or was hit slightly?
                   // Only trigger nextDelivery if it clearly passed the wicket or was hit.
                   // Let's refine: Trigger nextDelivery always after a ball reaches the batsman's wicket line if not hit/wicket.
                   if (reachedBatsman && game.ball.state === 'bowling' && !game.canBat) { // If canBat is false, it means bat didn't connect
                        game.message = game.lastBallAction || 'No run.'; // If no action yet, default to no run
                         if (!game.lastBallAction) game.lastBallAction = 'dot'; // Ensure action is set
                         nextDelivery();
                   }
              }
          }
      }

      // After any score or wicket, check if innings or game is over
      // This check is also done in nextDelivery, which is called by score/wicket actions.
  }


  // --- Input Handling ---

  function handleMouseDown(event) {
      event.preventDefault(); // Prevent default touch behavior like scrolling

      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      if (game.state === 'Playing') {
          if (game.bowlingTeam === 'player' && game.ball.state === 'idle' && game.canBowl) {
              // Player is bowling, initiate bowl
              playerBowl(mouseX, mouseY);
          } else if (game.battingTeam === 'player' && game.ball.state === 'bowling') {
              // Player is batting, check for joystick interaction or swing click
              const j = game.joystick;
              const distToJoystickCenter = Math.sqrt(Math.pow(mouseX - j.centerX, 2) + Math.pow(mouseY - j.centerY, 2));
              const joystickAreaRadius = j.radius * 2.5; // Same as draw area

              if (distToJoystickCenter <= joystickAreaRadius) {
                  // Started drag on joystick area
                  j.active = true;
                  j.startX = mouseX;
                  j.startY = mouseY;
                  j.currentX = mouseX; // Initialize thumb position
                  j.currentY = mouseY;
                  game.inputActive = true; // Input is related to batting control
              } else if (game.inputActive) { // If input is active (joystick being used), a click outside swings
                 playerBatSwing(); // Click anywhere while joystick active initiates swing
              }
          }
      }
  }

  function handleMouseMove(event) {
       event.preventDefault();
       if (game.state === 'Playing' && game.battingTeam === 'player' && game.joystick.active) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const j = game.joystick;

            // Calculate distance and angle from center
            let deltaX = mouseX - j.centerX;
            let deltaY = mouseY - j.centerY;
            const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            // Clamp distance to joystick radius
            if (dist > j.radius) {
                deltaX = (deltaX / dist) * j.radius;
                deltaY = (deltaY / dist) * j.radius;
            }

            j.currentX = j.centerX + deltaX;
            j.currentY = j.centerY + deltaY;

            // Calculate angle and power
            j.angle = Math.atan2(deltaY, deltaX);
            j.power = dist / j.radius; // Normalized power (0 to 1)

            // Set bat angle based on joystick angle
            // Need to map joystick angle (-PI to PI) to bat swing angle (e.g., -PI/2 to 0 or PI/2)
            // Joystick UP is typically towards top of canvas (negative Y). Bat swing up is towards PITCH_Y (less Y) or away from PITCH_Y depending on pivot.
            // Let's assume angle 0 is right, PI/2 is down, PI is left, -PI/2 is up.
            // We want joystick Up/Down to control vertical bat angle, Left/Right to control horizontal angle (less relevant in 2D side view)
            // A simple mapping: Joystick Y position controls bat angle. Top of joystick range maps to max upward swing, bottom to max downward.
            const swingRange = Math.PI / 2; // Example: Bat swings from horizontal (0) to vertical up/down (PI/2 or -PI/2) relative to a base position.
            const baseAngle = 0; // Assume bat rests horizontally for now
            // Map Y position from center -radius to center +radius -> swing from -swingRange/2 to +swingRange/2
            // Negative deltaY is "up" on screen, positive deltaY is "down"
            const mappedAngle = baseAngle + (deltaY / j.radius) * (swingRange / 2);
            game.batsman.batAngle = mappedAngle; // Use this for drawing and collision
        }
  }

  function handleMouseUp(event) {
       event.preventDefault();
       if (game.state === 'Playing' && game.battingTeam === 'player' && game.joystick.active) {
            game.joystick.active = false;
            // Optional: Trigger swing on release if no separate swing click/button
            // playerBatSwing(); // Enable this line if swing is on joystick release
            game.inputActive = false; // Input session ended
       }
  }

  // Add touch support
  function handleTouchStart(event) {
      if (event.touches.length > 0) {
          // Use the first touch point
          handleMouseDown({
              clientX: event.touches[0].clientX,
              clientY: event.touches[0].clientY,
              preventDefault: event.preventDefault,
              target: event.target // Pass target for getBoundingClientRect
          });
      }
  }

  function handleTouchMove(event) {
      if (event.touches.length > 0) {
           handleMouseMove({
              clientX: event.touches[0].clientX,
              clientY: event.touches[0].clientY,
              preventDefault: event.preventDefault,
               target: event.target
           });
      }
  }

  function handleTouchEnd(event) {
       handleMouseUp({ preventDefault: event.preventDefault }); // Simplified - doesn't need clientX/Y
  }


  // --- Game Actions ---

  function playerBowl(mouseX, mouseY) {
      if (game.ball.state !== 'idle' || !game.canBowl) return;

      // Bowl originates near bowler
      const startX = game.bowler.x + game.bowler.width / 2;
      const startY = game.bowler.y + game.bowler.height / 2;

      // Target is influenced by click position, but constrained towards the wicket
      const targetX = PITCH_START_X + WICKET_WIDTH/2 + (mouseX - PITCH_START_X - WICKET_WIDTH/2) * 0.2; // Aim towards wicket area, slightly influenced by click
      const targetY = PITCH_Y + (mouseY - PITCH_Y) * 0.5; // Influence vertical direction

      const angle = Math.atan2(targetY - startY, targetX - startX);
      const speed = MIN_BALL_SPEED + Math.random() * (MAX_BALL_SPEED - MIN_BALL_SPEED) * 0.5; // Base speed + randomness

      game.ball.x = startX;
      game.ball.y = startY;
      game.ball.dx = Math.cos(angle) * speed;
      game.ball.dy = Math.sin(angle) * speed;
      game.ball.state = 'bowling';
      game.canBowl = false; // Cannot bowl again until next delivery

      game.message = 'Ball is bowled!';

      // Reset bat angle for player
       if (game.battingTeam === 'player') {
           game.batsman.batAngle = 0; // Reset bat position
           game.batsman.swinging = false;
           game.batsman.swingProgress = 0;
           game.canBat = true; // Allow bat input again
           game.inputActive = false; // Reset input state
           game.joystick.active = false;
           game.joystick.currentX = game.joystick.centerX;
           game.joystick.currentY = game.joystick.centerY;
       }

       // If AI is batting, trigger AI bat decision soon after ball is bowled
       if (game.battingTeam === 'ai') {
           setTimeout(aiBat, 500 + Math.random() * 500); // AI decides to bat after a short delay
       }
  }

  function playerBatSwing() {
      if (game.ball.state === 'bowling' && !game.batsman.swinging && game.canBat && game.battingTeam === 'player') {
          game.batsman.swinging = true;
          game.batsman.swingProgress = 0; // Start swing animation
           // Bat angle is already set by joystick move handler
      }
  }

  // --- AI Logic ---

  function aiBowl() {
       if (game.ball.state !== 'idle' || !game.canBowl) return;

       // Bowl originates near AI bowler
       const startX = game.bowler.x + game.bowler.width / 2;
       const startY = game.bowler.y + game.bowler.height / 2;

       // AI targets batsman wicket area with some randomness
       const targetX = PITCH_END_X - WICKET_WIDTH/2 + (Math.random() - 0.5) * 30; // Target wicket area +- 15px
       const targetY = PITCH_Y + (Math.random() - 0.5) * 20; // Target pitch center +- 10px vertical

       const angle = Math.atan2(targetY - startY, targetX - startX);
       const speed = MIN_BALL_SPEED * 0.8 + Math.random() * (MAX_BALL_SPEED - MIN_BALL_SPEED); // Slightly less minimum speed, more randomness

       game.ball.x = startX;
       game.ball.y = startY;
       game.ball.dx = Math.cos(angle) * speed;
       game.ball.dy = Math.sin(angle) * speed * (Math.random() > 0.8 ? 1.5 : 1); // Occasional faster/wider ball
       game.ball.state = 'bowling';
       game.canBowl = false;

       game.message = 'AI is bowling...';

        // Reset bat angle for player
       if (game.battingTeam === 'player') {
           game.batsman.batAngle = 0; // Reset bat position
           game.batsman.swinging = false;
           game.batsman.swingProgress = 0;
           game.canBat = true; // Allow bat input again
           game.inputActive = false; // Reset input state
           game.joystick.active = false;
           game.joystick.currentX = game.joystick.centerX;
           game.joystick.currentY = game.joystick.centerY;
       }
  }

   function aiBat() {
       if (game.ball.state !== 'bowling' || !game.canBat || game.battingTeam !== 'ai') return;

       const ball = game.ball;
       const bat = game.batsman;
       const wicketX = PITCH_END_X - WICKET_WIDTH / 2; // AI batsman's wicket X

       // Simple AI: Check if ball is near the wicket AND within a reasonable vertical range
       const distanceToWicketX = Math.abs(ball.x - wicketX);
       const distThreshold = 150; // How close the ball needs to be horizontally
       const verticalThreshold = 30; // How close the ball needs to be vertically to pitch center

       if (distanceToWicketX < distThreshold && Math.abs(ball.y - PITCH_Y) < verticalThreshold) {
           // Decide whether to swing (AI might sometimes miss intentionally or just not react)
           if (Math.random() < 0.8) { // 80% chance to attempt a shot
               game.batsman.swinging = true;
               game.batsman.swingProgress = 0;
               game.canBat = false; // AI swings once

               // AI Swing Angle and Power (simple randomness)
               // AI tries to hit straight or slightly angled
               const baseAngle = Math.atan2(PITCH_Y - (bat.y + bat.height * 0.75), wicketX - (bat.x + bat.width / 2)); // Angle towards center/wicket
               game.batsman.batAngle = baseAngle + (Math.random() - 0.5) * Math.PI / 4; // Base angle +/- 22.5 degrees
               game.joystick.power = 0.5 + Math.random() * 0.5; // Power between 0.5 and 1
           } else {
               // AI decides not to swing or misses
               game.message = 'AI missed';
               game.canBat = false; // AI cannot swing this delivery now
           }
       } else if (ball.x < wicketX - 50 && game.canBat){ // If ball passes far from wicket without swing attempt
            game.message = 'AI left it';
            game.canBat = false; // AI decided not to swing
       }
   }

  // --- Game Loop ---

  function update() {
      // Update ball position if it's moving
      if (game.ball.state !== 'idle') {
          game.ball.x += game.ball.dx;
          game.ball.y += game.ball.dy;

          // Apply simple friction/drag off the pitch
          if (game.ball.state === 'batted' && (game.ball.x < PITCH_START_X || game.ball.x > PITCH_END_X)) {
              game.ball.dx *= 0.98; // Reduce speed
              game.ball.dy *= 0.98;
          }


          // Check boundaries/wickets (simplified scoring/wickets)
          if (game.ball.state === 'bowling') {
             checkCollision(); // Check for bat collision *while* bowling
             // checkScore will be called if the ball reaches the batsman's wicket area without collision
          } else if (game.ball.state === 'batted') {
              checkScore(); // Check for boundary score or if ball stops
          }


          // If ball goes way off screen, reset it (handle edge case)
           if (Math.abs(game.ball.x) > GAME_WIDTH * 2 || Math.abs(game.ball.y) > GAME_HEIGHT * 2) {
               console.warn("Ball went far off screen, resetting.");
               game.lastBallAction = 'dot'; // Assume it was a miss/stopped ball off screen
               nextDelivery();
           }
      }

      // Update batsman swing animation
      if (game.batsman.swinging) {
         game.batsman.swingProgress += BAT_SWING_SPEED;
         // The bat angle should move from its starting position towards the target angle set by joystick/AI
         // A simple animation: swing from current angle towards the stored j.angle/ai angle
         // Let's make it simpler: when swinging, the angle smoothly moves *to* the set game.batsman.batAngle
         // This requires storing the start angle when swing starts.
         // Let's refine: When playerBatSwing or aiBat is called, store target angle. Animate from current angle to target.
         // Re-simplifying: The bat angle is JUST set by the joystick (player) or AI decision. The `swinging` flag just enables collision detection during this time window.
         // If swingProgress reaches 1 (or some threshold), reset swinging
         if (game.batsman.swingProgress >= BAT_SWING_ARC) { // Use the arc size as a duration proxy
            game.batsman.swinging = false;
            game.batsman.swingProgress = 0; // Reset for next swing
             // The bat angle should probably return to a ready position after swing?
             // game.batsman.batAngle = 0; // Reset angle after swing animation
         }
      }

      // Check game progress (overs, wickets, score, innings break, game over)
      // These checks are primarily triggered by nextDelivery, endOver, endInnings, endGame
      // Also need to trigger nextDelivery if a bowled ball reaches the batsman area and wasn't hit/wicket
      if (game.ball.state === 'bowling' && !game.canBat) { // If bat input was checked but didn't hit
           const batsmanWicketX = game.battingTeam === 'player' ? PITCH_START_X + WICKET_WIDTH/2 : PITCH_END_X - WICKET_WIDTH/2;
            const reachedBatsman = (game.bowlingTeam === 'ai' && game.ball.x <= batsmanWicketX) ||
                                   (game.bowlingTeam === 'player' && game.ball.x >= batsmanWicketX);
           if (reachedBatsman) {
                // Ball reached batsman area and wasn't hit or a wicket
                // If checkScore didn't already trigger nextDelivery (e.g. for wide/miss)
                // We need to ensure nextDelivery is called ONCE per completed ball
                // Let's rely on checkScore or an explicit state change to trigger nextDelivery
                // A simple timeout might be needed if checkScore doesn't handle all miss cases immediately.
                // Let's add a check for ball passing the wicket area without hit/wicket.
                 if (!game.lastBallAction && reachedBatsman && Math.abs(game.ball.x - batsmanWicketX) < 20 && game.ball.state === 'bowling') {
                      game.message = 'No run.';
                      game.lastBallAction = 'dot';
                      nextDelivery();
                 }
           }
      }

       // If AI is bowling and ball is idle, initiate AI bowl
       if (game.state === 'Playing' && game.bowlingTeam === 'ai' && game.ball.state === 'idle' && game.canBowl) {
           setTimeout(aiBowl, 1000 + Math.random() * 1000); // AI bowls after a delay
       }
  }


  function draw() {
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT); // Clear canvas

    drawPitch();
    drawBatsman();
    drawBowler();
    drawBall();
    drawScoreboard();
    drawMessage();

    if (game.state === 'Playing' && game.battingTeam === 'player') {
        drawJoystick();
    }
     // Other UI (Toss, Game Over) handled by overlay DOM
  }

  function gameLoop() {
    update();
    draw();
    game.animationId = requestAnimationFrame(gameLoop);
  }

  // --- Overlay & UI Handlers ---
  function updateOverlay(type = 'show') {
      overlay.innerHTML = ''; // Clear current overlay content

      if (type === 'hide') {
          overlay.style.display = 'none';
          return;
      }

      overlay.style.display = 'flex';

      let content = '';

      switch (game.state) {
          case 'Loading':
              content = '<h2>2D Cricket</h2><p>Loading...</p>'; // Should be quick
              setTimeout(initGame, 100); // Initialize after a brief pause
              break;
          case 'Menu':
              content = '<h2>2D Cricket</h2><p>Simple 2D Cricket Game</p><button onclick="startGame()">START GAME</button>';
              break;
          case 'Toss':
              if (game.message) content += `<p>${game.message}</p>`;
              if (!game.playerTossChoice) {
                   content += `<div><button onclick="handleToss('heads')">Heads</button><button onclick="handleToss('tails')">Tails</button></div>`;
              }
              break;
          case 'InningsBreak':
              content = `<h2>Innings Break</h2><p>${game.message}</p><p>Current Score:</p><p>YOU: ${game.score.player}/${game.wickets.player} | AI: ${game.score.ai}/${game.wickets.ai}</p>`;
              if (game.innings === 2) {
                 content += `<p>${game.battingTeam === 'player' ? 'You' : 'AI'} need ${game.target + 1 - game.score[game.battingTeam]} runs to win.</p>`;
              }
              content += `<button onclick="startInnings()">Start ${game.innings} Innings</button>`;
              break;
          case 'GameOver':
               content = `<h2>Game Over</h2><p>${game.message}</p><button onclick="initGame()">Play Again</button>`;
               break;
          case 'Playing':
               // Overlay should be hidden in Playing state
               overlay.style.display = 'none';
               break;
      }

      // Special toss result phase - waits for user click to proceed after result is shown
      if (type === 'tossResult') {
           content = `<h2>Toss Result</h2><p>${game.message}</p><button onclick="startInnings()">Proceed to Innings ${game.innings}</button>`;
      } else if (type === 'chooseBatBowl') {
           content = `<h2>Toss Result</h2><p>${game.message}</p><div><button onclick="handleTossChoice('bat')">Bat</button><button onclick="handleTossChoice('bowl')">Bowl</button></div>`;
      }


      overlay.innerHTML = content;
  }


  // --- Event Listeners ---
  canvas.addEventListener('mousedown', handleMouseDown);
  canvas.addEventListener('mousemove', handleMouseMove);
  canvas.addEventListener('mouseup', handleMouseUp);

  canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
  canvas.addEventListener('touchend', handleTouchEnd, { passive: false });


  // --- Start Game ---
  // Initial call to set up the menu
  initGame();
  // Start the game loop, which will initially draw the menu state
  gameLoop();

</script>

</body>
</html>